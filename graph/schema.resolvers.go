package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"fmt"
	"time"

	"github.com/guptaaashutosh/gqlgen-prac/controller"
	"github.com/guptaaashutosh/gqlgen-prac/graph/model"
)

// Chapter is the resolver for the chapter field.
func (r *bookDetailsResolver) Chapter(ctx context.Context, obj *model.BookDetails) ([]*model.Chapter, error) {
	return controller.Chapter(ctx, r.DB, obj)
}

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input model.NewBook) (*model.Book, error) {
	return controller.CreateBook(ctx, r.DB, input)
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (*model.DeletedBook, error) {
	return controller.DeleteBook(ctx, r.DB, id)
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, input model.UpdateBook) (*model.UpdatedBook, error) {
	return controller.UpdateBook(ctx, r.DB, input)
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: CreateUser - createUser"))
	return controller.CreateNewUser(ctx, r.DB, input)
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, email string, password string) (*model.LoginDetails, error) {
	// panic(fmt.Errorf("not implemented: LoginUser - loginUser"))
	return controller.LoginUserController(ctx, r.DB, email, password)
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id string) (*model.Book, error) {
	return controller.GetBook(ctx, id)
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	return controller.GetBooks(ctx, r.DB)
}

// GetBooksWithLimitOffset is the resolver for the getBooksWithLimitOffset field.
func (r *queryResolver) GetBooksWithLimitOffset(ctx context.Context, limit int, offset int) ([]*model.Book, error) {
	// panic(fmt.Errorf("not implemented: GetBooksWithLimitOffset - getBooksWithLimitOffset"))
	return controller.GetBooksUsingLimitOffset(ctx, r.DB, limit, offset)
}

// BookWithChapter is the resolver for the bookWithChapter field.
func (r *queryResolver) BookWithChapter(ctx context.Context, id string) (*model.BookDetails, error) {
	return controller.BookWithChapter(ctx, r.DB, id)
}

// BooksWithChapters is the resolver for the booksWithChapters field.
func (r *queryResolver) BooksWithChapters(ctx context.Context, ids []string) ([]*model.BookDetails, error) {
	// panic(fmt.Errorf("not implemented: BooksWithChapters - booksWithChapters"))
	return controller.BooksWithChapters(ctx, ids)
}

// GetBooksWithIds is the resolver for the getBooksWithIds field.
func (r *queryResolver) GetBooksWithIds(ctx context.Context, ids []string) ([]*model.Book, error) {
	// panic(fmt.Errorf("not implemented: GetBooksWithIds - getBooksWithIds"))
	return controller.GetBooksWithIds(ctx, ids)
}

// GetCurrentTime is the resolver for the getCurrentTime field.
func (r *queryResolver) GetCurrentTime(ctx context.Context) (*model.Subscription, error) {
	// panic(fmt.Errorf("not implemented: GetCurrentTime - getCurrentTime"))
	return r.GetCurrentTime(ctx)
}

// TotalBooks is the resolver for the totalBooks field.
func (r *queryResolver) TotalBooks(ctx context.Context, id string) (*model.TotalBooks, error) {
	panic(fmt.Errorf("not implemented: TotalBooks - totalBooks"))
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id int) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: GetUser - getUser"))
	return controller.GetUserWithUserId(ctx, r.DB, id)
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*model.User, error) {
	// panic(fmt.Errorf("not implemented: GetUsers - getUsers"))
	// fmt.Println(ctx.Value(middleware.AuthCtx))
	return controller.GetUsers(ctx, r.DB)
}

// CurrentTime is the resolver for the currentTime field.
func (r *subscriptionResolver) CurrentTime(ctx context.Context) (<-chan *model.Time, error) {
	// panic(fmt.Errorf("not implemented: CurrentTime - currentTime"))
	ch := make(chan *model.Time)
	go func() {
		defer close(ch)
		for {
			time.Sleep(1 * time.Second)
			currentTime := time.Now()
			t := &model.Time{
				UnixTime:  int(currentTime.Unix()),
				TimeStamp: currentTime.Format(time.RFC3339),
			}
			//select statement is same like switch statement, but in the select statement, case statement refers to communication,
			//i.e. send and receive operation on channel
			//Select statement waits until the communication(send or receive operation) is prepared for some cases to begin.
			select {
			case <-ctx.Done():
				fmt.Println("subscription closed.")
				return
			case ch <- t:
				// Our message went through, do nothing
			}
		}
	}()
	return ch, nil
}

// BookConnection is the resolver for the bookConnection field.
func (r *totalBooksResolver) BookConnection(ctx context.Context, obj *model.TotalBooks, first *int, after *string) (*model.BookConnection, error) {
	panic(fmt.Errorf("not implemented: BookConnection - bookConnection"))
}

// BookDetails returns BookDetailsResolver implementation.
func (r *Resolver) BookDetails() BookDetailsResolver { return &bookDetailsResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// TotalBooks returns TotalBooksResolver implementation.
func (r *Resolver) TotalBooks() TotalBooksResolver { return &totalBooksResolver{r} }

type bookDetailsResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type totalBooksResolver struct{ *Resolver }
